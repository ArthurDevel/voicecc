# Conversation Watch Endpoint (SSE)

## Goal

Add real-time conversation streaming to the dashboard. Currently, the ConversationView component fetches messages once from JSONL and never updates. For active voice sessions, users want to see messages appear live as they're spoken and as Claude responds.

The solution uses Server-Sent Events (SSE) to stream both historic and live messages through a single endpoint.

## Architecture

**Three-part flow:**

1. **Sidecar â†’ Dashboard**: Voice session pushes stream chunks via HTTP POST as Claude responds
2. **Dashboard server**: Holds active streams in memory (Map of sessionId â†’ chunks), broadcasts to SSE clients
3. **Dashboard frontend â†’ Server**: Connects via SSE, receives historic messages immediately, then live updates

**Key design decisions:**
- Endpoint name: `/watch` (not `/sse` or `/stream`) â€” reflects dual responsibility of loading history + streaming live
- No duplication: SSE sends complete history first, then only new chunks
- No race conditions: Single request handles both past and future messages
- Memory management: Active streams cleared when session ends

---

## File Changes

```
dashboard/
  routes/
    conversations.ts         (MOD) Add POST /push, GET /:sessionId/watch
  src/
    components/
      ConversationView.tsx   (MOD) Replace fetch with EventSource SSE
sidecar/
  voice-session.ts           (MOD) Push stream chunks to dashboard via HTTP POST
  types.ts                   (MOD) Add StreamChunk type
```

---

## Types

### dashboard/routes/conversations.ts (NEW)

```typescript
StreamChunk {
  role: "user" | "assistant" | "tool_start" | "tool_end"
  content: string
  timestamp: string
}

ActiveStream {
  sessionId: string
  chunks: StreamChunk[]
  clients: Set<ServerResponse>  // SSE connections
}
```

### sidecar/types.ts (NEW)

```typescript
StreamChunk {
  role: "user" | "assistant" | "tool_start" | "tool_end"
  content: string
  timestamp: string
}
```

---

## Methods

### dashboard/routes/conversations.ts (MODIFIED)

Module-level state (closure-scoped):
```typescript
const activeStreams = new Map<string, ActiveStream>()
```

#### New Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `handlePushChunk` | `c: Context` | `Promise<Response>` | POST /:sessionId/push. Body: `{ role, content, timestamp }`. Adds chunk to active stream, broadcasts to all connected SSE clients. If no active stream exists, creates one. Returns 200. |
| `handleWatchConversation` | `c: Context` | `Promise<Response>` | GET /:sessionId/watch. Sets `Content-Type: text/event-stream`. Loads historic messages from JSONL (via existing `parseSessionMessages`), sends as SSE `data:` events. Adds client to active stream's client set. Keeps connection open for live updates. On client disconnect: removes from set, if set is empty after 30s, clears the stream from memory. |
| `broadcastToClients` | `stream: ActiveStream, chunk: StreamChunk` | `void` | Sends SSE `data:` event to all clients in `stream.clients`. Format: `data: ${JSON.stringify(chunk)}\n\n`. Silently removes clients whose write fails (disconnected). |

#### Modified Routes

```typescript
app.post("/:sessionId/push", handlePushChunk)
app.get("/:sessionId/watch", handleWatchConversation)
```

---

### sidecar/voice-session.ts (MODIFIED)

Add dashboard push logic to `processClaudeResponse` and `handleCompleteTurn`.

#### Modified Functions

| Function | Change | Description |
|----------|--------|-------------|
| `handleCompleteTurn` | After transcription, push user message chunk | POST to `http://localhost:${DASHBOARD_PORT}/api/conversations/${sessionId}/push` with `{ role: "user", content: transcript, timestamp: new Date().toISOString() }`. Silently ignore errors (dashboard may not be running). |
| `processClaudeResponse` | Stream assistant text chunks to dashboard | For each `text_delta` event from Claude stream, accumulate text until a sentence boundary (`.`, `!`, `?`, newline) or buffer reaches 100 chars. Push accumulated chunk via POST. Also push tool_start and tool_end events with tool name as content. |

**Sentence boundary logic:**
- Accumulate text deltas into a buffer
- On each delta, scan for sentence-ending punctuation followed by whitespace or end-of-stream
- When found: push the sentence as a chunk, clear buffer
- On stream end: push any remaining buffer as final chunk

**Why push incrementally?**
- Better UX: messages appear as Claude speaks them, not all at once at the end
- Matches the streaming TTS experience (user hears audio in real-time)

#### Dashboard Port Discovery

Read `DASHBOARD_PORT` from environment variable (set by `dashboard/routes/voice.ts` when launching the sidecar via Terminal). Default to 3456 if not set.

```typescript
const DASHBOARD_PORT = process.env.DASHBOARD_PORT || "3456"
```

---

### dashboard/src/components/ConversationView.tsx (MODIFIED)

Replace `fetch` with `EventSource` for SSE.

#### Changes

```typescript
useEffect(() => {
  const eventSource = new EventSource(`/api/conversations/${sessionId}/watch`)

  eventSource.onmessage = (event) => {
    const chunk: StreamChunk = JSON.parse(event.data)
    setMessages(prev => [...prev, {
      role: chunk.role,
      content: chunk.content,
      timestamp: chunk.timestamp
    }])
  }

  eventSource.onerror = () => {
    setError("Connection lost")
    eventSource.close()
  }

  return () => eventSource.close()
}, [sessionId])
```

**Auto-scroll behavior:**
- Keep existing `useEffect` that scrolls to bottom when `messages` updates
- Works automatically with SSE since each chunk appends to `messages`

---

## Important Technical Notes

### SSE Message Format

Server sends:
```
data: {"role":"user","content":"hello","timestamp":"2026-02-20T..."}\n\n
```

Must include **two newlines** after each event. Browser `EventSource` API parses this automatically.

### Client Disconnection Cleanup

When a client disconnects (user navigates away or closes tab), the SSE response stream errors. Hono's response object will throw when attempting to write. Catch this in `broadcastToClients` and remove the dead client from the set.

If the client set becomes empty after a disconnect, start a 30-second timer. If still empty when the timer fires, delete the stream from `activeStreams` map (garbage collect).

**Why 30 seconds?**
- Allows for quick reconnects (page refresh, network blip)
- Prevents memory leaks for abandoned sessions
- Short enough to avoid unbounded memory growth

### Session ID Discovery

Voice session needs its session ID to construct the push URL. The Claude Code SDK provides this via the `system` event. Currently, `voice-session.ts` doesn't track it.

**Solution:**
- In `voice-session.ts`, the Claude session already emits a `system` event with `session_id` (line 144 in `sidecar/claude-session.ts`)
- Capture this in a closure variable: `let sessionId = ""`
- On first `system` event: `sessionId = msg.session_id`
- Use it for push URLs

### Push Error Handling

Dashboard may not be running (user started voice via `npx tsx sidecar/index.ts` directly, bypassing the dashboard). Push requests will fail with ECONNREFUSED.

**Solution:** Wrap all push calls in try/catch, silently ignore errors. Streaming still works via JSONL file writes (existing behavior).

### Historic Message Deduplication

The existing `parseSessionMessages` function already handles deduplication (assistant messages by `requestId`, user messages by `uuid`). Use it as-is for the historic load phase of the SSE endpoint.

### Memory Leak Prevention

Active streams persist in memory until explicitly cleared. Without cleanup, a long-running dashboard with many sessions will accumulate unbounded state.

**Mitigation:**
1. When all SSE clients disconnect, start 30s timer
2. If timer fires and set is still empty, delete stream from map
3. When voice session ends (stop phrase or hangup), sidecar should send a special "end" push that tells dashboard to clear the stream immediately

**End signal:**
```typescript
POST /:sessionId/push
Body: { role: "end", content: "", timestamp: "..." }
```

Dashboard removes stream from map on receiving this event.

### Concurrent Voice Sessions

Multiple sessions can be active simultaneously (local mic + phone call, or multiple phone calls up to `MAX_CONCURRENT_SESSIONS`). Each gets its own stream in the map. No conflicts since they're keyed by unique session IDs.

### Text Accumulation for Sentence Chunks

Claude streams text deltas character-by-character or word-by-word. Pushing every delta would spam the dashboard with tiny fragments.

**Chunking strategy:**
- Buffer text until hitting a sentence boundary (`.!?\n`) followed by space/newline/EOS
- Also flush if buffer exceeds 100 chars (prevent unbounded accumulation for run-on text)
- On stream end, flush any remaining buffer

**Regex for sentence boundary:**
```typescript
const isSentenceEnd = (text: string) => /[.!?]\s*$/.test(text)
```

This matches punctuation at the end, optionally followed by whitespace.

### Tool Events

Claude emits tool_use content blocks. Show these in the conversation view as structured events (e.g., "ðŸ”§ Running: Read tool"). Push as separate chunks with `role: "tool_start"` and `role: "tool_end"`.

**Format:**
- `tool_start`: content = tool name (e.g., "Read")
- `tool_end`: content = empty or result summary

---

## Phases

### Phase 1: Dashboard SSE Endpoint âœ…

1. Add `activeStreams` map to `dashboard/routes/conversations.ts`
2. Implement `handlePushChunk` (POST /:sessionId/push)
3. Implement `handleWatchConversation` (GET /:sessionId/watch)
   - Load historic messages via existing `parseSessionMessages`
   - Send as SSE events
   - Add client to stream's set
   - Register disconnect cleanup with 30s timer
4. Implement `broadcastToClients` helper
5. Mount new routes in `conversationRoutes()`

### Phase 2: Sidecar Push Integration âœ…

1. Add `DASHBOARD_PORT` env var read in `sidecar/voice-session.ts`
2. Capture `sessionId` from Claude `system` event
3. Push user messages in `handleCompleteTurn`
4. Push assistant text chunks in `processClaudeResponse`
   - Implement sentence boundary detection
   - Implement 100-char flush threshold
5. Push tool events (tool_start, tool_end)
6. Push "end" signal in session teardown

### Phase 3: Frontend SSE Client âœ…

1. Replace `fetch` with `EventSource` in `ConversationView.tsx`
2. Handle `onmessage`: append chunks to messages array
3. Handle `onerror`: display connection error, close EventSource
4. Cleanup: close EventSource on unmount

### Phase 3.5: Sidebar Polling

1. Add `setInterval` in `Sidebar.tsx` to poll `/api/conversations` every 5 seconds
2. Update conversations list with fresh data
3. Cleanup: clear interval on unmount
4. Preserve selection state across refreshes

**Implementation:**
```typescript
useEffect(() => {
  const fetchConversations = () => {
    get<ConversationSummary[]>("/api/conversations")
      .then(setConversations)
      .catch(() => {});
  };

  // Initial fetch
  fetchConversations();

  // Poll every 5 seconds
  const interval = setInterval(fetchConversations, 5000);

  return () => clearInterval(interval);
}, []);
```

### Phase 4: Testing âœ…

1. Start dashboard, start voice session, verify messages appear live
2. Navigate away from conversation view, verify memory cleanup after 30s
3. Start multiple sessions, verify no cross-talk
4. Kill voice session mid-response, verify dashboard cleans up stream
5. Refresh page during active session, verify reconnect works
6. Start voice without dashboard, verify no crashes (push errors ignored)
7. Verify sidebar updates with new conversations within 5 seconds

---

## Success Criteria

- User messages appear in dashboard immediately after transcription
- Assistant responses stream in sentence-by-sentence as Claude generates them
- Tool calls show as structured events in the message list
- Historic conversations load instantly (from JSONL)
- Active conversations update live (via SSE)
- No duplication of messages (historic + live are distinct phases)
- Memory cleanup works (streams removed after clients disconnect + 30s)
- Voice session runs without dashboard (push errors silently ignored)
- Multiple concurrent sessions work independently
- Sidebar refreshes conversation list every 5 seconds (new sessions appear automatically)

# Browser Call from Anywhere -- Direct WebSocket Audio

## High Level Goal

Replace the Twilio WebRTC browser calling path with a direct WebSocket + AudioWorklet implementation. The browser captures mic audio via `getUserMedia()` + `AudioWorkletNode`, sends raw PCM over a WebSocket to a lightweight server, and receives TTS audio back over the same WebSocket. This eliminates the Twilio Voice SDK dependency for browser calls entirely -- no Twilio account, no API keys, no per-minute charges.

**What stays:** Twilio integration for PSTN phone calls (incoming/outgoing to real phone numbers). ngrok for tunneling. Device pairing for authentication.

**What goes:** `@twilio/voice-sdk` dependency, Twilio token generation for browser calls, TwiML app creation for WebRTC, the entire "webrtc" mode of `TwilioPanel`.

---

## File Tree

```
yangon-v1/
├── sidecar/
│   ├── browser-server.ts          # NEW  - WebSocket server for browser audio sessions
│   │                              #        Runs on TWILIO_PORT (default 8080), same as twilio-server
│   │                              #        Only one of browser-server / twilio-server runs at a time
│   ├── browser-audio.ts           # NEW  - BrowserAudioAdapter implements AudioAdapter
│   ├── chime.ts                   # NEW  - shared decodeChimeToPcm() utility (extracted from twilio-audio.ts)
│   ├── audio-adapter.ts           # UNCHANGED
│   ├── voice-session.ts           # UNCHANGED
│   ├── session-lock.ts            # UNCHANGED
│   ├── twilio-server.ts           # UNCHANGED (kept for PSTN)
│   ├── twilio-audio.ts            # MODIFIED - extract decodeChimeToPcm() to chime.ts, import from there
│   ├── local-audio.ts             # UNCHANGED
│   └── index.ts                   # UNCHANGED
│
├── services/
│   ├── browser-call-manager.ts    # NEW  - spawn/stop browser-server child process
│   ├── ngrok.ts                   # UNCHANGED
│   ├── device-pairing.ts          # UNCHANGED
│   ├── env.ts                     # UNCHANGED
│   └── twilio-manager.ts          # UNCHANGED (kept for PSTN)
│
├── dashboard/
│   ├── public/
│   │   └── audio-processor.js     # NEW  - AudioWorklet processor (must be static asset, not bundled)
│   │
│   ├── routes/
│   │   ├── browser-call.ts        # NEW  - API routes for browser call status/start/stop
│   │   ├── twilio.ts              # MODIFIED - remove /setup-webrtc, /token, webrtcReady from status
│   │   ├── webrtc.ts              # UNCHANGED (pairing stays)
│   │   └── ...                    # other routes unchanged
│   │
│   ├── src/
│   │   ├── pages/
│   │   │   ├── Home.tsx           # MODIFIED - remove webrtcReady from TwilioStatus, add BrowserCallStatus type
│   │   │   ├── Settings.tsx       # MODIFIED - remove webrtcReady from TwilioStatus init, add browser call status polling
│   │   │   ├── Call.tsx           # MODIFIED - replace Twilio Voice SDK with AudioWorklet + WebSocket
│   │   │   └── ...
│   │   │
│   │   ├── components/
│   │   │   ├── BrowserCallSetupPanel.tsx  # NEW  - setup wizard (ngrok only, no Twilio creds)
│   │   │   ├── BrowserCallModal.tsx       # MODIFIED - use browser-call status for ngrok URL
│   │   │   ├── Sidebar.tsx                # MODIFIED - use browserCallStatus for "Call via Browser" button
│   │   │   ├── Layout.tsx                 # MODIFIED - poll browser-call status, pass to Sidebar
│   │   │   ├── TwilioPanel.tsx            # MODIFIED - remove "webrtc" mode, keep "twilio" mode only
│   │   │   └── ...
│   │   │
│   │   └── App.tsx                # UNCHANGED (route /call already exists)
│   │
│   └── server.ts                  # MODIFIED - register browser-call routes
│
├── package.json                   # MODIFIED - remove @twilio/voice-sdk dependency
└── ...
```

---

## Per-File Methods and Types

### sidecar/browser-audio.ts (NEW)

AudioAdapter implementation for direct browser WebSocket connections.
Receives PCM float32 16kHz from browser, sends PCM int16 24kHz (from TTS) back.
Simpler than TwilioAudioAdapter -- no mulaw codec, no Twilio-specific protocol framing.

Chime handling: calls shared `decodeChimeToPcm()` from `sidecar/chime.ts` at initialization and caches the buffer for `playChime()`.

#### Types

```
BrowserAudioAdapterConfig {
  ws: WebSocket                    // Active WebSocket connection to browser
}
```

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `createBrowserAudioAdapter` | `config: BrowserAudioAdapterConfig` | `AudioAdapter` | Factory that creates an AudioAdapter for browser WebSocket audio I/O. Calls `decodeChimeToPcm()` from `chime.ts` and caches the result. |

**AudioAdapter interface methods (implemented):**

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `onAudio` | `callback: (samples: Float32Array) => void` | `void` | Registers WebSocket binary message handler. Incoming binary messages are raw Float32Array PCM at 16kHz. Converts Buffer to Float32Array and invokes callback. Ignores text (JSON) messages. |
| `writeSpeaker` | `pcm: Buffer` | `Promise<void>` | Sends 24kHz int16 PCM buffer as binary WebSocket message. Uses `ws.send(data, callback)` to resolve the promise on write completion (backpressure). Silently returns if WebSocket is closed. |
| `interrupt` | none | `void` | Sends JSON `{"type":"clear"}` text message over the WebSocket to tell the browser to flush its playback buffer. |
| `resume` | none | `void` | No-op. Browser AudioWorklet resumes consuming from ring buffer automatically after clear. |
| `playChime` | none | `void` | Sends cached chime PCM via `writeSpeaker()`. |
| `destroy` | none | `void` | No-op. WebSocket lifecycle managed by browser-server.ts. |

### sidecar/chime.ts (NEW)

Shared utility for decoding the macOS ready chime to raw PCM. Extracted from `twilio-audio.ts` to avoid duplicating the `afconvert` + temp file logic across adapters.

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `decodeChimeToPcm` | none | `Buffer` | Decodes macOS Glass.aiff to raw 24kHz int16 mono PCM via `afconvert`. Uses a unique temp file path (`/tmp/chime-24k-<pid>.raw`) to avoid race conditions if multiple adapters initialize concurrently. |

### sidecar/twilio-audio.ts (MODIFIED)

**Changes:**
- Remove `decodeChimeToPcm()` function (moved to `chime.ts`)
- Import `decodeChimeToPcm` from `./chime.js`
- Remove `READY_CHIME_PATH` and `CHIME_TEMP_PATH` constants (moved to `chime.ts`)
- No other changes

### sidecar/browser-server.ts (NEW)

Standalone HTTP + WebSocket server for browser audio sessions.
Runs on TWILIO_PORT (default 8080) -- same port as twilio-server.ts. Only one runs at a time.
Proxies non-audio HTTP requests to the dashboard server (same pattern as twilio-server.ts).
Entry point for the browser call sidecar process.

#### Types

```
ActiveBrowserSession {
  deviceToken: string              // The device token used for this session
  session: VoiceSession | null     // Voice session handle (null until created)
}
```

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `startBrowserServer` | none (reads env vars) | `Promise<void>` | Starts HTTP server on TWILIO_PORT (default 8080). Creates WebSocketServer (noServer mode). Registers upgrade handler. Throws if DASHBOARD_PORT not set. Also sends periodic `ws.ping()` every 30s to keep connections alive through ngrok. |
| `handleWebSocketUpgrade` | `req: IncomingMessage, socket: Duplex, head: Buffer, wss: WebSocketServer` | `void` | Validates path is `/audio`. Extracts device token from query string `?token=<token>`. Checks localhost or validates via `isValidDeviceToken()`. Rejects duplicate connections for the same device token. Accepts or destroys socket. |
| `handleBrowserSession` | `ws: WebSocket, deviceToken: string` | `void` | Creates BrowserAudioAdapter + VoiceSession (using browser-tuned DEFAULT_CONFIG with `interruptionThresholdMs: 1500` -- lower than Twilio's 2000ms because browser getUserMedia includes AEC). Registers close/error handlers for cleanup. Removes from activeSessions map on disconnect. |

### services/browser-call-manager.ts (NEW)

Process management for the browser-server sidecar. Analogous to twilio-manager.ts but simpler (no TwiML app updates, no Twilio SDK dependency).

#### Types

```
BrowserCallStatus {
  running: boolean                  // Whether browser-server process is alive
}
```

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `startBrowserCallServer` | `dashboardPort: number` | `Promise<void>` | Spawns `browser-server.ts` as child process with `DASHBOARD_PORT` env var. Uses TWILIO_PORT from .env (default 8080). Pipes stdout/stderr with `[browser-server]` prefix. Throws if already running. |
| `stopBrowserCallServer` | none | `void` | Sends SIGTERM to child process, clears state. |
| `getBrowserCallStatus` | none | `BrowserCallStatus` | Returns `{ running }`. |
| `isBrowserCallRunning` | none | `boolean` | Returns running state. |

### dashboard/routes/browser-call.ts (NEW)

API routes for browser call server management.

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `browserCallRoutes` | none | `Hono` | Returns Hono route group with the endpoints below. |

**Endpoints:**

| Endpoint | Method | Response | Description |
|----------|--------|----------|-------------|
| `/status` | GET | `{ running: boolean, ngrokUrl: string \| null }` | Returns browser call server running state + current ngrok URL |
| `/start` | POST | `{ success: boolean }` | Reads TWILIO_PORT from .env (default 8080). Starts ngrok on that port if not running. Then starts browser-server. Returns error if Twilio server is already running on that port. |
| `/stop` | POST | `{ success: boolean }` | Stops browser-server + ngrok. |

### dashboard/public/audio-processor.js (NEW)

AudioWorklet processor that runs in the browser's audio rendering thread.
Must be a standalone JS file in `public/` (Vite cannot bundle AudioWorklet processors into the main chunk -- `addModule()` requires a separate file URL).

Handles both mic capture (input -> main thread) and speaker playback (main thread -> output).

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `process` | `inputs: Float32Array[][], outputs: Float32Array[][], parameters` | `boolean` | AudioWorkletProcessor.process(). Copies input channel 0 to a buffer. When buffer reaches CHUNK_SIZE (512 samples), posts it to main thread via port. For output, reads from playback ring buffer and writes to output channel 0. Returns true to keep processor alive. |

**Message protocol (port.postMessage):**

| Direction | Message | Description |
|-----------|---------|-------------|
| Processor -> Main | `{ type: "audio", samples: Float32Array }` | Chunk of mic audio (float32, browser sample rate) |
| Main -> Processor | `{ type: "playback", samples: Float32Array }` | TTS audio chunk for speaker output |
| Main -> Processor | `{ type: "clear" }` | Flush the playback ring buffer (interruption) |

### dashboard/src/pages/Call.tsx (MODIFIED)

Replace Twilio Voice SDK with direct WebSocket + AudioWorklet.

**Removed:**
- `@twilio/voice-sdk` dynamic import
- Twilio Device creation, registration, connection
- `GET /api/twilio/token` fetch

**Added:**
- `getUserMedia({ audio: true })` for mic access (with error handling for permission denial)
- `AudioContext` creation + explicit `audioContext.resume()` call (browser autoplay policy)
- `AudioWorkletNode` setup via `audioContext.audioWorklet.addModule("/audio-processor.js")`
- WebSocket connection to `wss://${window.location.host}/audio?token=<deviceToken>` (uses current host, no need to fetch ngrok URL separately)
- Resampling logic in main thread: browser sample rate (typically 48kHz) <-> 16kHz/24kHz
- Binary WebSocket messages for audio, JSON messages for control (`clear`)

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `startCall` | none | `Promise<void>` | Gets mic stream via `getUserMedia`. Creates AudioContext, calls `resume()`. Loads AudioWorklet module. Creates AudioWorkletNode. Opens WebSocket to `/audio?token=...`. Wires up: worklet mic -> resample -> WS send, WS receive -> resample -> worklet playback. Handles `getUserMedia` denial with user-facing error. |
| `hangUp` | none | `void` | Closes WebSocket, stops all mic MediaStream tracks, closes AudioContext. |
| `downsampleToTarget` | `input: Float32Array, fromRate: number, toRate: number` | `Float32Array` | Downsampler using 3-tap averaging before decimation (same approach as `downsample24to8` in twilio-audio.ts). |
| `upsampleFromTarget` | `input: Float32Array, fromRate: number, toRate: number` | `Float32Array` | Linear interpolation upsampler. |

### dashboard/src/pages/Home.tsx (MODIFIED)

**Changes:**
- Remove `webrtcReady` from `TwilioStatus` interface
- Add `BrowserCallStatus` interface: `{ running: boolean, ngrokUrl: string | null }`
- Both types exported for use by Layout.tsx, Sidebar.tsx, Settings.tsx

### dashboard/src/pages/Settings.tsx (MODIFIED)

**Changes:**
- Remove `webrtcReady: false` from `TwilioStatus` initial state
- Import `BrowserCallStatus` from `Home.tsx`
- Add `browserCallStatus` state + polling from `/api/browser-call/status`
- (TwilioPanel is still accessible from Settings for PSTN setup)

### dashboard/src/components/BrowserCallSetupPanel.tsx (NEW)

Setup wizard for "Browser Call from Anywhere" in Settings. Replaces the "webrtc" mode of TwilioPanel.

3 steps:
1. Check ngrok installed + enter authtoken
2. Start/stop server (shows ngrok URL when running)
3. Show status + link to call page

#### Types

```
BrowserCallSetupPanelProps {
  onClose: () => void
}
```

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `BrowserCallSetupPanel` | `props: BrowserCallSetupPanelProps` | `JSX.Element` | Renders the 3-step setup modal. Polls `/api/browser-call/status` every 5s. Checks ngrok installed via `/api/ngrok/check`. Saves ngrok authtoken via `/api/settings`. Starts/stops via `/api/browser-call/start` and `/stop`. |

### dashboard/src/components/BrowserCallModal.tsx (MODIFIED)

**Changes:**
- Accept `ngrokUrl` from `BrowserCallStatus` instead of `TwilioStatus`
- No other changes (QR code, pairing code flow stays the same)

### dashboard/src/components/Sidebar.tsx (MODIFIED)

**Changes:**
- Add `browserCallStatus: BrowserCallStatus` to props interface
- `browserCallEnabled` checks `browserCallStatus.running && !!browserCallStatus.ngrokUrl` (replaces the `twilioStatus.running && twilioStatus.webrtcReady && !!twilioStatus.ngrokUrl` check)
- Pass `browserCallStatus.ngrokUrl` to `BrowserCallModal`
- Keep `twilioStatus` prop for potential future PSTN UI indicators

### dashboard/src/components/Layout.tsx (MODIFIED)

**Changes:**
- Add polling for `GET /api/browser-call/status`
- Pass `browserCallStatus` to Sidebar alongside `twilioStatus`

### dashboard/src/components/TwilioPanel.tsx (MODIFIED)

**Changes:**
- Remove the `"webrtc"` mode entirely. Delete the `mode` prop and all `mode === "webrtc"` conditional branches.
- Remove step 4 ("Enable browser calling") and `handleSetupWebrtc`.
- This component now only handles PSTN phone setup.

### dashboard/routes/twilio.ts (MODIFIED)

**Removed:**
- `POST /setup-webrtc` endpoint
- `GET /token` endpoint
- `webrtcReady` field from `/status` response
- `twilioSdk.jwt.AccessToken` usage
- `isValidDeviceToken` import (no longer needed here)

**Added:**
- Symmetric port conflict check: `POST /start` rejects if `isBrowserCallRunning()` (prevents starting Twilio server while browser-server holds the port)

### dashboard/server.ts (MODIFIED)

**Changes:**
- Import and mount `browserCallRoutes()` at `/api/browser-call`

### package.json (MODIFIED)

**Changes:**
- Remove `@twilio/voice-sdk` from dependencies (browser SDK, ~2MB). The `twilio` server SDK stays for PSTN.

---

## Important Technical Notes

### Port Sharing: browser-server and twilio-server

Both `browser-server.ts` and `twilio-server.ts` run on the same port (TWILIO_PORT, default 8080). They are mutually exclusive -- the `/api/browser-call/start` endpoint checks if the Twilio server is already running and rejects if so, and vice versa. The ngrok tunnel always points to this port regardless of which server is behind it.

### AudioWorklet as a Static Asset

AudioWorklet processors must be loaded via `audioContext.audioWorklet.addModule(url)`. Vite cannot bundle them into the main JS chunk. The file goes in `dashboard/public/audio-processor.js` (plain JS, no TypeScript) so Vite copies it as-is to `dist/audio-processor.js`. The Call page loads it via `addModule("/audio-processor.js")`.

### AudioWorklet + Resampling

The browser's `AudioContext` typically runs at 48kHz (system default). The voice pipeline expects 16kHz input and produces 24kHz output. Resampling happens in the main thread before/after WebSocket send/receive.

**Mic path (browser -> server):**
1. AudioWorklet captures float32 at browser sample rate (e.g. 48kHz)
2. Posts chunks to main thread via `port.postMessage`
3. Main thread downsamples 48kHz to 16kHz (3-tap average + decimation, same approach as `downsample24to8` in twilio-audio.ts)
4. Sends as binary WebSocket message (Float32Array buffer)
5. Server's `BrowserAudioAdapter.onAudio` receives Float32Array directly

**Speaker path (server -> browser):**
1. Server sends int16 24kHz PCM as binary WebSocket message (with backpressure via ws.send callback)
2. Main thread receives, converts int16 to float32, upsamples from 24kHz to browser sample rate
3. Posts to AudioWorklet via `port.postMessage`
4. AudioWorklet writes to output from ring buffer

### WebSocket Protocol

Binary messages = audio data. JSON text messages = control signals.

**Client -> Server:**
- Binary: Float32Array PCM at 16kHz (already resampled by client)

**Server -> Client:**
- Binary: Int16Array PCM at 24kHz (TTS output, client upsamples)
- JSON `{"type":"clear"}`: Flush playback buffer (interruption)

### Authentication on WebSocket Upgrade

The device token is passed as a query parameter: `/audio?token=<deviceToken>`. The server validates via existing `isValidDeviceToken()` from `services/device-pairing.ts`. Localhost connections skip token validation (same as current `/api/twilio/token` behavior).

Duplicate connections from the same device token are rejected -- the server tracks active sessions by token. This prevents multiple tabs from consuming session slots.

Note: the token appears in the URL (ngrok logs, etc). Acceptable for a local dev tool. An alternative would be `Sec-WebSocket-Protocol` header, but query parameter is simpler and sufficient.

### WebSocket Keepalive

The server sends `ws.ping()` every 30 seconds to prevent ngrok from closing idle connections (ngrok has idle timeouts). This covers the gap between pairing and starting to speak.

### Playback Ring Buffer in AudioWorklet

The AudioWorklet processor uses a ring buffer for speaker playback:
- Pre-allocated Float32Array (48000 samples = 1 second at 48kHz)
- Read/write pointers
- On `"clear"` message, reset both pointers to 0
- Bridges timing: WebSocket chunks (variable size) -> process() calls (128-sample frames)
- On overflow (write catches up to read): drop incoming samples rather than overwriting unplayed audio

### Browser AudioContext Autoplay Policy

Modern browsers create `AudioContext` in suspended state. The plan calls `audioContext.resume()` inside the `startCall` click handler, which satisfies the user gesture requirement.

### getUserMedia Permission Denial

If the user denies microphone access, `startCall` catches the error and displays "Microphone access denied. Please allow microphone access and try again." in the call UI. The call state returns to "ready".

---

## Phases

### Phase 1: Server-side -- BrowserAudioAdapter + BrowserServer

- [ ] Create `sidecar/chime.ts` -- extract `decodeChimeToPcm()` from twilio-audio.ts with PID-based temp file path
- [ ] Modify `sidecar/twilio-audio.ts` -- import `decodeChimeToPcm` from chime.ts, remove local copy
- [ ] Create `sidecar/browser-audio.ts` -- implement `createBrowserAudioAdapter()` with AudioAdapter interface, using chime.ts, backpressure on writeSpeaker
- [ ] Create `sidecar/browser-server.ts` -- HTTP server on TWILIO_PORT, WebSocket upgrade with token validation, duplicate device token rejection, session management, dashboard proxying, ping keepalive, browser-tuned DEFAULT_CONFIG (interruptionThresholdMs: 1500)
- [ ] Create `services/browser-call-manager.ts` -- spawn/stop child process

### Phase 2: Dashboard API routes

- [ ] Create `dashboard/routes/browser-call.ts` -- status/start/stop endpoints (with port conflict check against Twilio server)
- [ ] Modify `dashboard/routes/twilio.ts` -- add symmetric port conflict check against browser-call server in POST /start
- [ ] Modify `dashboard/server.ts` -- mount browser-call routes

### Phase 3: Client-side -- AudioWorklet + Call page

- [ ] Create `dashboard/public/audio-processor.js` -- AudioWorklet processor with ring buffer
- [ ] Modify `dashboard/src/pages/Call.tsx` -- replace Twilio SDK with AudioWorklet + WebSocket, add resampling, handle getUserMedia denial, call audioContext.resume()

### Phase 4: Dashboard UI updates

- [ ] Modify `dashboard/src/pages/Home.tsx` -- remove webrtcReady from TwilioStatus, add BrowserCallStatus type
- [ ] Modify `dashboard/src/pages/Settings.tsx` -- remove webrtcReady from TwilioStatus init, add browser call status polling
- [ ] Create `dashboard/src/components/BrowserCallSetupPanel.tsx` -- 3-step setup wizard
- [ ] Modify `dashboard/src/components/Sidebar.tsx` -- use browserCallStatus for "Call via Browser" button
- [ ] Modify `dashboard/src/components/Layout.tsx` -- poll browser-call status
- [ ] Modify `dashboard/src/components/BrowserCallModal.tsx` -- use browser-call status for ngrok URL

### Phase 5: Remove Twilio WebRTC code

- [ ] Modify `dashboard/src/components/TwilioPanel.tsx` -- remove "webrtc" mode, keep "twilio" only
- [ ] Modify `dashboard/routes/twilio.ts` -- remove /setup-webrtc, /token, webrtcReady
- [ ] Modify `package.json` -- remove `@twilio/voice-sdk`

### Phase 6: Build + Verify

- [ ] Build dashboard (`npm run build:dashboard`)
- [ ] Verify no TypeScript errors
- [ ] Verify no broken imports after Twilio WebRTC removal

---

## Success Criteria

- Browser call works end-to-end: mic audio captured in browser -> WebSocket -> server VAD/STT -> Claude -> TTS -> WebSocket -> browser speaker
- No Twilio dependency for browser calling (no Twilio credentials needed in setup)
- Device pairing flow works identically (6-digit code, QR code, device token persistence)
- PSTN phone calls via Twilio still work (twilio-server.ts untouched)
- Interruption detection works during browser calls
- Session lock enforced across browser + local + Twilio sessions
- Unauthorized WebSocket upgrade requests are rejected (invalid/missing token)
- Duplicate tabs for same device token are rejected
- Dashboard setup wizard has only 3 steps (ngrok install, authtoken, start server)
- `@twilio/voice-sdk` removed from package.json
- Dashboard builds successfully

# Startup Audio + Parallel Init

## High-Level Goal

Eliminate the 10-40 second silence users experience when starting a voice session by:
1. **Option A**: Playing a pre-recorded startup message immediately (before any module loads)
2. **Option C**: Parallelizing the sequential module initialization (`Promise.all` instead of sequential `await`)

## File Tree

```
sidecar/
  scripts/
    generate-startup-audio.py   (NEW)  - one-time script to generate startup audio via mlx_audio Kokoro model
  assets/
    startup.pcm                 (NEW)  - raw 24kHz 16-bit mono PCM audio (no header, ready for writeSpeaker)
  voice-session.ts              (MOD)  - play startup audio before init, parallelize module init with Promise.all
```

## Per-File Methods and Types

### generate-startup-audio.py (NEW)

Script that uses `mlx_audio.tts.utils.load_model` (same API as `tts-server.py`) to generate a short startup message and save it as raw PCM.

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `main` | none | none | Uses `from mlx_audio.tts.utils import load_model` to load the Kokoro model, calls `model.generate(text=..., voice=...)`, converts float32 chunks to int16 PCM, concatenates, and writes raw bytes to `sidecar/assets/startup.pcm` |

### voice-session.ts (MODIFIED)

#### Changes

| Change | Description |
|--------|-------------|
| Add module-scoped `STARTUP_PCM` | Reads `assets/startup.pcm` once at module load time using `__dirname` resolution (same pattern as `tts.ts` line 78-79). Wrapped in try/catch, set to `null` if file missing. Cached for all sessions (relevant for Twilio where `createVoiceSession` is called per incoming call) |
| Play startup audio | After acquiring session lock, call `adapter.writeSpeaker(STARTUP_PCM)` inside a try/catch (so a write failure does not abort init). Await it (the write is fast, audio plays from VPIO/Twilio buffer while init runs) |
| Parallelize init | Replace sequential `await` calls with `Promise.all([createClaudeSession(...), createTts(...)])`, followed by sequential `createVad(...)` then `createStt(...)`. Endpointer and narrator remain after (synchronous, instant) |

## Important Technical Notes

### Audio playback during init

`adapter.writeSpeaker(pcm)` writes PCM data into the audio output pipeline (VPIO stdin for local, WebSocket for Twilio). The data is accepted by the stream immediately and playback begins in the background. This means the startup message plays through the speakers while `Promise.all` runs the module initialization in parallel.

### Raw PCM instead of WAV

The generation script outputs raw PCM bytes directly (no WAV header). This avoids needing to parse WAV headers at runtime, since the WAV format allows variable-length headers with optional metadata chunks. The format is fixed: 24kHz, 16-bit signed, mono -- matching what `writeSpeaker` expects on both adapters.

### ONNX runtime parallel safety

Both `avr-vad` (VAD) and `sherpa-onnx-node` (STT) use dynamic imports to avoid ONNX runtime conflicts. The comments in `vad.ts:60` and `stt.ts:82` reference a conflict with `kokoro-js`, which runs in the TTS Python subprocess (separate process), not in the Node process. However, loading both native ONNX runtimes concurrently within the same Node process may still conflict. To be safe, VAD and STT remain sequential relative to each other, but run in parallel with Claude session and TTS startup.

### Twilio compatibility

The Twilio adapter's `writeSpeaker` internally converts 24kHz PCM to 8kHz mulaw before sending over WebSocket. A ~2-second startup message produces ~16KB of mulaw payload, well within Twilio WebSocket message limits. Twilio may drop audio sent immediately after the "start" event (before the outbound path is fully established). This needs to be tested empirically -- if audio is dropped, a follow-up change would add a short delay (e.g., wait for the first inbound media packet before sending).

### Graceful degradation

Both the file read (module load) and the `writeSpeaker` call (per session) are wrapped in try/catch. If `startup.pcm` is missing, unreadable, or the write fails, the session starts normally without a startup message. This prevents a missing or broken asset from affecting functionality.

## Phases

### Phase 1: Generate the startup audio file
- [ ] Create `sidecar/scripts/generate-startup-audio.py` using `mlx_audio.tts.utils.load_model` API (matching `tts-server.py`)
- [ ] Create `sidecar/assets/` directory
- [ ] Run the script from the `sidecar/` directory (requires the `.venv` Python environment) to produce `sidecar/assets/startup.pcm`
- [ ] Verify the file plays correctly (e.g., `ffplay -f s16le -ar 24000 -ac 1 sidecar/assets/startup.pcm`)

### Phase 2: Play startup audio and parallelize init in voice-session.ts
- [ ] Add module-scoped `STARTUP_PCM: Buffer | null` that reads `assets/startup.pcm` with try/catch at load time
- [ ] After acquiring the session lock, play startup audio via `adapter.writeSpeaker()` wrapped in try/catch
- [ ] Parallelize: `Promise.all([createClaudeSession(...), createTts(...)])` for the slow modules
- [ ] Keep VAD and STT sequential (after the Promise.all) due to potential ONNX conflicts
- [ ] Keep endpointer and narrator creation after (synchronous, no change needed)

## Success Criteria

- The user hears a spoken startup message within <1 second of starting a voice session
- All independent modules initialize in parallel, reducing total init time
- Both local mic and Twilio phone sessions play the startup message correctly
- A missing startup.pcm file or a writeSpeaker failure does not prevent sessions from starting
- No regressions in the voice loop state machine or interruption handling

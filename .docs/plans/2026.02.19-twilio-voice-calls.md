# Plan: Twilio Voice Call Support

## High-level Goal

Add phone call support via Twilio alongside the existing local laptop mic. Users can call a phone number and talk to Claude via the same voice pipeline. The voice loop logic is extracted into a shared module with swappable audio I/O adapters, making it easy to add more transports later (e.g. WhatsApp).

Both audio paths (laptop mic and phone call) must work independently. They run as **separate processes** -- `index.ts` for local mic, `twilio-server.ts` for phone calls. They do not share state or run in the same process.

A global session limit (`MAX_CONCURRENT_SESSIONS`) is enforced across all processes via PID-based lock files, preventing resource exhaustion (each session spawns a TTS subprocess using ~3GB GPU memory).

---

## File Tree

```
sidecar/
  audio-adapter.ts        (NEW)  -- AudioAdapter interface definition
  voice-session.ts        (NEW)  -- Shared voice loop logic extracted from index.ts
  session-lock.ts         (NEW)  -- Cross-process session limiter via PID lock files
  local-audio.ts          (NEW)  -- VPIO-based AudioAdapter for laptop mic
  twilio-audio.ts         (NEW)  -- Twilio WebSocket AudioAdapter + mulaw conversion
  twilio-server.ts        (NEW)  -- HTTP/WebSocket server for Twilio calls
  index.ts                (MOD)  -- Simplified to thin wrapper: creates local adapter + voice session
  audio-capture.ts        (-)    -- Unchanged, used internally by local-audio.ts (singleton module)
  claude-session.ts       (-)    -- Unchanged
  endpointing.ts          (-)    -- Unchanged
  narration.ts            (-)    -- Unchanged
  stt.ts                  (-)    -- Unchanged
  tts.ts                  (-)    -- Unchanged
  tts-server.py           (-)    -- Unchanged
  vad.ts                  (-)    -- Unchanged
  types.ts                (MOD)  -- Remove sampleRate from VoiceLoopConfig (adapter concern)
  mic-vpio.swift          (-)    -- Unchanged
.env                      (NEW)  -- Configuration: MAX_CONCURRENT_SESSIONS, Twilio credentials
dashboard/
  server.ts               (MOD)  -- Add REST endpoints for .env settings
  public/index.html       (MOD)  -- Add settings panel for .env editing
package.json              (MOD)  -- Add ws, twilio, @types/ws, dotenv
```

Note: `audio-capture.ts` uses module-level singleton state (one VPIO process). Only one local adapter can exist per process. This is fine because local mic and Twilio run as separate processes.

---

## Per-file Methods and Types

### audio-adapter.ts (NEW)

Defines the AudioAdapter interface that abstracts audio I/O for the voice session. Any transport (local mic, Twilio, WhatsApp) implements this.

#### Types

```
AudioAdapter {
  onAudio: (callback: (samples: Float32Array) => void) => void
  writeSpeaker: (pcm: Buffer) => Promise<void>
  interrupt: () => void
  resume: () => void
  playChime: () => void
  destroy: () => void
}
```

- `onAudio` -- subscribe to incoming audio chunks (Float32Array, 16kHz, normalized -1.0 to 1.0). The callback is synchronous (returns `void`). The consumer (`voice-session.ts`) wraps async work in `.catch()` internally, matching the existing pattern in `index.ts` line 178.
- `writeSpeaker` -- write PCM audio to the output (16-bit signed, 24kHz mono). Returns a promise for backpressure.
- `interrupt` -- clear output audio buffer immediately (for user interruption)
- `resume` -- resume output after interrupt (must be called before writing new audio)
- `playChime` -- play the ready chime through the output
- `destroy` -- clean up all resources

---

### session-lock.ts (NEW)

Cross-process session limiter using PID-based lock files. Ensures the total number of active voice sessions (local mic + Twilio combined) does not exceed `MAX_CONCURRENT_SESSIONS`.

Lock directory: `~/.claude-voice-sessions/`

Each lock file contains the PID of the owning process. On every acquire, stale files (where the PID is no longer alive) are cleaned up automatically.

#### Types

```
SessionLock {
  release: () => void
}
```

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `acquireSessionLock` | `maxSessions: number` | `SessionLock` | Lists lock files, validates each PID is alive (deletes stale ones), throws if count >= maxSessions. Creates a new lock file with the current PID. Also registers `process.on('exit')` to auto-release. Returns a handle with `release()`. |
| `isProcessAlive` | `pid: number` | `boolean` | Checks if a process exists using `process.kill(pid, 0)` (signal 0 does not kill -- it only checks existence). Returns true if alive, false if not. |

---

### voice-session.ts (NEW)

Contains all the voice loop logic currently in `index.ts`, but per-session (closure-based state, not module-level). Uses AudioAdapter for all I/O.

#### Types

```
VoiceSessionConfig {
  sttModelPath: string
  ttsModel: string
  ttsVoice: string
  modelCacheDir: string
  stopPhrase: string
  interruptionThresholdMs: number
  endpointing: EndpointingConfig
  narration: NarrationConfig
  claudeSession: ClaudeSessionConfig
  onSessionEnd: () => void
}

VoiceSession {
  stop: () => Promise<void>
}
```

`VoiceSessionConfig` is like the current `VoiceLoopConfig` but:
- Removes `sampleRate` (adapter concern)
- Adds `onSessionEnd` callback, invoked when the stop phrase is detected. Local path uses this to exit the process; Twilio uses it to close the WebSocket.
- Adds `interruptionThresholdMs` (default 1500ms for local mic with VPIO echo cancellation; phone calls may need a higher value like 2000-2500ms since there is no local echo cancellation).

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `createVoiceSession` | `adapter: AudioAdapter, config: VoiceSessionConfig` | `Promise<VoiceSession>` | Acquires a session lock (throws if limit reached). Initializes all pipeline modules (VAD, STT, endpointer, Claude session, narrator, TTS), subscribes to adapter audio, starts the state machine. Returns a handle with `stop()` which releases the lock. |

Internal functions (not exported, closure-scoped):

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `handleAudioChunk` | `samples: Float32Array` | `Promise<void>` | Feeds audio to VAD and accumulates for STT during speech (including `sttProcessor.clearBuffer()` during interruption detection). Replaces `handleMicChunk` from index.ts but receives Float32Array directly (adapter does the conversion). |
| `handleVadEvent` | `event: VadEvent` | `void` | Routes VAD events based on current state (listening vs speaking/processing). Same logic as index.ts. |
| `handleListeningVadEvent` | `event: VadEvent` | `void` | Handles SPEECH_START/CONTINUE/END during LISTENING state. |
| `handleSpeechEnd` | `event: VadEvent` | `Promise<void>` | Transcribes accumulated audio, checks endpointing. |
| `handleCompleteTurn` | `transcript: string` | `Promise<void>` | Checks stop phrase (calls `config.onSessionEnd()` if matched), sends transcript to Claude. |
| `processClaudeResponse` | `transcript: string` | `Promise<void>` | Streams Claude response through narrator into TTS. Uses `adapter.playChime()` after response completes. |
| `handleInterruptionDetection` | `event: VadEvent` | `void` | Detects sustained speech during SPEAKING/PROCESSING for interruption. Uses `config.interruptionThresholdMs` for the timer. Calls `sttProcessor.clearBuffer()` on SPEECH_START (matching existing behavior). |
| `triggerInterruption` | (none) | `void` | Interrupts TTS and Claude, transitions to LISTENING. |
| `handleStateTransition` | `from: VoiceLoopState, event: string` | `VoiceLoopState` | Pure state machine transition function. Same as index.ts. |

`TtsConfig` interface remains unchanged. `voice-session.ts` wraps `adapter.writeSpeaker` in a Node.js `Writable` stream and passes `adapter.interrupt`/`adapter.resume` as the `interruptPlayback`/`resumePlayback` callbacks. TTS module stays completely unaware of the transport.

---

### local-audio.ts (NEW)

Wraps the existing `audio-capture.ts` into the AudioAdapter interface for the laptop mic path.

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `createLocalAudioAdapter` | `micRate: number, speakerRate: number` | `Promise<AudioAdapter>` | Starts the VPIO binary via `startCapture()`, wires stdout through `bufferToFloat32` to the onAudio callback, returns an AudioAdapter. |

Internal behavior:
- `onAudio`: listens to VPIO stdout, converts each Buffer chunk via `bufferToFloat32()`, calls the registered callback
- `writeSpeaker`: writes Buffer directly to VPIO stdin (with backpressure handling)
- `interrupt`: sends SIGUSR1 to VPIO process (via `interruptPlayback()`)
- `resume`: sends SIGUSR2 to VPIO process (via `resumePlayback()`)
- `playChime`: spawns `afplay --volume 6 /System/Library/Sounds/Glass.aiff`
- `destroy`: calls `stopCapture()` to kill VPIO process

---

### twilio-audio.ts (NEW)

AudioAdapter implementation for Twilio media streams. Also contains mulaw codec and resampling utilities.

#### Types

```
TwilioAudioAdapterConfig {
  ws: WebSocket
  streamSid: string
}
```

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `createTwilioAudioAdapter` | `config: TwilioAudioAdapterConfig` | `AudioAdapter` | Creates an AudioAdapter that reads/writes audio over a Twilio WebSocket media stream. Decodes the Glass.aiff chime to PCM once during initialization and caches the buffer for `playChime`. |
| `mulawDecode` | `byte: number` | `number` | Decode a single mulaw byte to a 16-bit linear PCM sample. G.711 standard. |
| `mulawEncode` | `sample: number` | `number` | Encode a single 16-bit linear PCM sample to a mulaw byte. G.711 standard. |
| `twilioPayloadToFloat32` | `base64Payload: string` | `Float32Array` | Converts Twilio media payload (base64 mulaw 8kHz) to Float32Array at 16kHz. Steps: base64 decode -> mulaw to PCM int16 -> upsample 2x -> normalize to float32. |
| `pcm24kToTwilioPayload` | `pcmBuffer: Buffer` | `string` | Converts TTS PCM output (24kHz int16) to Twilio media payload (base64 mulaw 8kHz). Steps: downsample 3x -> mulaw encode -> base64. |

Internal behavior:
- `onAudio`: registers a WebSocket `message` handler. On `media` events, calls `twilioPayloadToFloat32` and invokes the callback. Stops invoking callback if WebSocket has closed.
- `writeSpeaker`: calls `pcm24kToTwilioPayload`, sends `{ event: "media", streamSid, media: { payload } }` over WebSocket. Silently returns if WebSocket is closed (session is tearing down). Backpressure is not a concern at telephony bitrates (~8KB/s for mulaw 8kHz).
- `interrupt`: sends `{ event: "clear", streamSid }` over WebSocket (clears Twilio's audio buffer).
- `resume`: no-op (Twilio accepts new audio immediately after clear).
- `playChime`: sends the cached chime PCM buffer through `writeSpeaker`.
- `destroy`: no-op (WebSocket lifecycle managed by twilio-server.ts).

---

### twilio-server.ts (NEW)

HTTP + WebSocket server that accepts Twilio phone calls and creates a voice session per call.

#### Types

```
ActiveCall {
  callSid: string
  session: VoiceSession | null
}
```

State: `activeCalls = Map<string, ActiveCall>` keyed by token (the per-call UUID). Used to validate WebSocket upgrades and track sessions.

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `startTwilioServer` | (none) | `Promise<void>` | Starts the HTTP server on TWILIO_PORT (default 8080), attaches WebSocket upgrade handler. Reads config from `.env` via dotenv. Throws immediately if `TWILIO_AUTH_TOKEN` or `TWILIO_WEBHOOK_URL` are missing. |
| `handleIncomingCall` | `req: IncomingMessage, res: ServerResponse` | `void` | POST /twilio/incoming-call. Validates Twilio signature using the full public URL from `TWILIO_WEBHOOK_URL` env var (required because ngrok terminates TLS, so the server sees localhost but Twilio signed against the public URL). Generates per-call UUID token, adds to `activeCalls` map. Responds with TwiML XML. |
| `handleWebSocketUpgrade` | `req: IncomingMessage, socket: Duplex, head: Buffer` | `void` | Extracts token from URL path `/media/:token`, validates against `activeCalls` map, accepts or rejects WebSocket. |
| `handleCallSession` | `ws: WebSocket, token: string` | `void` | Listens for Twilio WebSocket events (start, media, stop). On `start`: creates TwilioAudioAdapter + voice session. If `createVoiceSession` throws (session limit reached), sends a `<Say>` message and closes. On `stop` or `ws.close`: tears down session. |

Teardown lifecycle:
- `onSessionEnd` (stop phrase detected): calls `ws.close()`. This triggers `ws.on('close')`.
- `ws.on('close')` (caller hangup OR stop phrase): calls `session.stop()` (which releases the session lock), removes entry from `activeCalls` map. Uses a `cleaned` flag to prevent double-cleanup (same pattern as `stopping` flag in current `index.ts`).
- This means `activeCalls` cleanup always happens in `ws.on('close')`, regardless of what caused the close.

Security:
- `handleIncomingCall` validates the `X-Twilio-Signature` header using `twilio.validateRequest(authToken, signature, webhookUrl, params)`. Uses `TWILIO_WEBHOOK_URL` env var for the URL. Returns 403 if invalid.
- `handleWebSocketUpgrade` checks that the token in the URL path matches an entry in `activeCalls`. Rejects unknown tokens.

---

### .env (NEW)

Configuration file read by both `index.ts` and `twilio-server.ts` via `dotenv`. Editable through the dashboard settings panel.

```
MAX_CONCURRENT_SESSIONS=2
TWILIO_AUTH_TOKEN=
TWILIO_WEBHOOK_URL=
TWILIO_PORT=8080
```

---

### dashboard/server.ts (MODIFIED)

Add REST endpoints for reading/writing the `.env` file, following the same pattern as the existing CLAUDE.md endpoints.

#### New Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `handleGetSettings` | `res: ServerResponse` | `void` | GET /api/settings. Reads `.env`, parses key=value pairs, returns as JSON. Masks `TWILIO_AUTH_TOKEN` value (shows only last 4 chars). |
| `handleUpdateSettings` | `req: IncomingMessage, res: ServerResponse` | `void` | POST /api/settings. Accepts JSON body with key-value pairs, writes to `.env`. |

---

### dashboard/public/index.html (MODIFIED)

Add a `.env` settings section **above** the existing CLAUDE.md editor on the same Settings page (not a separate tab). The settings section contains:
- Editable fields for `MAX_CONCURRENT_SESSIONS`, `TWILIO_AUTH_TOKEN`, `TWILIO_WEBHOOK_URL`, `TWILIO_PORT`
- Own save button (separate from the CLAUDE.md save)
- Auth token field is masked (show last 4 chars) with a reveal toggle
- Loads from `GET /api/settings`, saves via `POST /api/settings`
- The CLAUDE.md editor remains below, unchanged

---

### index.ts (MODIFIED)

Simplified to a thin wrapper. All voice loop logic moves to voice-session.ts.

Before: ~550 lines with full state machine, VAD routing, Claude processing, TTS streaming, etc.
After: ~30 lines creating a local adapter and voice session.

#### Methods

| Method | Arguments | Returns | Description |
|--------|-----------|---------|-------------|
| `main` | (none) | `Promise<void>` | Loads `.env` via dotenv. Creates a local AudioAdapter, creates a voice session with DEFAULT_CONFIG (including `onSessionEnd` that calls `process.exit()` and `interruptionThresholdMs: 1500`). `createVoiceSession` acquires a session lock (throws if limit reached). Registers SIGINT/SIGTERM handlers that call `session.stop()`. |

DEFAULT_CONFIG stays in this file (same values as today, minus `sampleRate`).

---

### types.ts (MODIFIED)

Remove `sampleRate` from `VoiceLoopConfig` since it is an adapter concern (passed to `createLocalAudioAdapter` / `createTwilioAudioAdapter`), not a voice session concern.

---

### package.json (MODIFIED)

Add dependencies:
- `ws: ^8.18.0` -- WebSocket server for Twilio media streams
- `twilio: ^5.0.0` -- Twilio request signature validation
- `dotenv: ^16.4.0` -- Load .env configuration
- `@types/ws: ^8.5.0` (dev) -- TypeScript types for ws

---

## Important Technical Notes

### Session lock mechanism

Cross-process session limiting uses PID-based lock files in `~/.claude-voice-sessions/`.

**Acquire flow:**
1. Ensure lock directory exists (`mkdir -p`)
2. List all `.lock` files in the directory
3. For each file, read the PID inside. Check if that process is alive using `process.kill(pid, 0)` -- signal 0 does not kill, it only checks existence. If the process is dead, delete the stale lock file.
4. Count remaining lock files. If >= `MAX_CONCURRENT_SESSIONS`, throw an error.
5. Create a new lock file (random UUID name) containing the current PID.
6. Register `process.on('exit')` handler to delete the lock file on shutdown.

**Release flow:** delete the lock file. Called by `session.stop()` and also by the `process.on('exit')` handler as a safety net.

This handles all crash scenarios: hard kill, SIGKILL, power loss. Stale files are cleaned up on the next session start.

### Mulaw codec (G.711)

The mu-law companding algorithm is a well-defined ITU-T standard. Encode and decode are each ~20 lines of bit manipulation. No lookup table needed, though one could be used for performance. The key formula:

```
Decode: sign * (((compressed & 0x0F) << 1) + 33) << ((compressed >> 4) & 7) - 33
Encode: find the segment (0-7) where the sample falls, extract 4 mantissa bits
```

Both operate on individual samples. No state or buffering required.

### Resampling (8kHz <-> 16kHz <-> 24kHz)

All ratios are integer factors, keeping the implementation trivial:

- **8kHz -> 16kHz** (factor 2x up): Linear interpolation. For N input samples, output 2N samples. For i = 0..N-2: `output[2i] = a[i]`, `output[2i+1] = (a[i] + a[i+1]) / 2`. Last sample: `output[2N-2] = a[N-1]`, `output[2N-1] = a[N-1]` (duplicate). Adequate for telephony speech (no content above 4kHz).

- **24kHz -> 8kHz** (factor 3x down): Average each group of 3 samples, output 1. This acts as a simple low-pass filter before decimation. Telephony output doesn't need high-frequency content.

### TTS speaker output as a Writable adapter

The existing TTS module (`tts.ts`) accepts `speakerInput: Writable` in its config. For the local path, this is VPIO's stdin. For Twilio, `voice-session.ts` wraps the adapter's `writeSpeaker` method in a Node.js `Writable` stream. The `_write` implementation must await the promise before calling callback, to correctly propagate backpressure:

```
new Writable({
  write(chunk, encoding, callback) {
    adapter.writeSpeaker(chunk as Buffer).then(() => callback(), callback);
  }
})
```

This keeps TTS completely unaware of the transport. `TtsConfig` interface remains unchanged.

### Chime for Twilio calls

The Glass.aiff chime is decoded to raw 24kHz PCM once during `createTwilioAudioAdapter` initialization and cached as a Buffer. On each `playChime()` call, the cached buffer is sent through `writeSpeaker`.

For the conversion, `afconvert` (macOS built-in) does not support stdout piping (`-o -`). Use a temp file instead:

```
afconvert -f caff -d LEI16@24000 -c 1 /System/Library/Sounds/Glass.aiff /tmp/chime-24k.raw
```

Read the temp file into a Buffer, then delete it. This only runs once at adapter init time.

### Twilio WebSocket message format

Incoming messages from Twilio are JSON with these event types:

- `{ "event": "connected" }` -- WebSocket connected
- `{ "event": "start", "start": { "streamSid": "...", "callSid": "...", ... } }` -- call started
- `{ "event": "media", "media": { "payload": "<base64 mulaw 8kHz>" } }` -- audio chunk (~20ms)
- `{ "event": "stop" }` -- call ended

Outgoing messages to Twilio:

- `{ "event": "media", "streamSid": "...", "media": { "payload": "<base64 mulaw 8kHz>" } }` -- send audio
- `{ "event": "clear", "streamSid": "..." }` -- clear Twilio's audio playback buffer (interrupt)

Note: Twilio supports `mark` events for playback synchronization, but we accept minor timing inaccuracy for the chime. The TTS module's existing playback-duration-based wait is sufficient.

### WebSocket close/error handling

If the caller hangs up mid-response, the WebSocket closes. `twilio-audio.ts` tracks WebSocket state (open/closed) and silently ignores `writeSpeaker` calls on a closed socket. `twilio-server.ts` registers `ws.on('close')` which handles all cleanup (session stop + lock release + active call slot removal), regardless of what caused the close (hangup, stop phrase, or error).

### Security model

Two gates prevent unauthorized access:

1. **Twilio signature validation** on the HTTP webhook. Twilio signs every request using your auth token. The `twilio` npm package provides `validateRequest(authToken, signature, url, params)`. The URL must be the public ngrok URL (provided via `TWILIO_WEBHOOK_URL` env var), not localhost. Without your `TWILIO_AUTH_TOKEN`, an attacker cannot forge a valid signature.

2. **Per-call random token** in the WebSocket URL. The TwiML response (only returned after signature validation) tells Twilio to connect to `wss://host/media/<uuid>`. The server maintains `activeCalls` map keyed by token and rejects any WebSocket upgrade with an unknown token. Since the token is delivered over HTTPS (ngrok), it cannot be intercepted.

### Interruption threshold tuning

The local mic path uses VPIO echo cancellation, so the interruption threshold (1500ms) only guards against noise spikes. Phone calls lack local echo cancellation -- Twilio provides network-level AEC which is less aggressive. The `interruptionThresholdMs` config allows Twilio to use a higher value (e.g. 2000-2500ms) to avoid false interruptions from the phone speaker bleeding into the mic. This will need tuning during Phase 4 testing.

---

## Phases

### Phase 1: AudioAdapter interface + voice-session extraction

1. Create `sidecar/audio-adapter.ts` with the AudioAdapter interface
2. Create `sidecar/session-lock.ts` with PID-based lock file mechanism
3. Create `.env` with `MAX_CONCURRENT_SESSIONS=2`
4. Create `sidecar/voice-session.ts` by extracting all voice loop logic from `index.ts`
   - Move state machine, VAD routing, speech handling, Claude processing, interruption detection
   - All state becomes closure-scoped inside `createVoiceSession`
   - Acquire session lock at start, release on stop
   - Replace `micStream.on("data")` with `adapter.onAudio()`
   - Replace `interruptPlayback`/`resumePlayback` with `adapter.interrupt()`/`adapter.resume()`
   - Replace `playReadyChime()` with `adapter.playChime()`
   - Wrap `adapter.writeSpeaker` in a Writable for TTS config (using the `_write` pattern above)
   - Use `config.onSessionEnd()` for stop phrase handling
   - Use `config.interruptionThresholdMs` for the interruption timer
5. Create `sidecar/local-audio.ts` wrapping `audio-capture.ts` into AudioAdapter
6. Update `sidecar/types.ts`: remove `sampleRate` from `VoiceLoopConfig`
7. Rewrite `sidecar/index.ts` to use `createLocalAudioAdapter` + `createVoiceSession` + dotenv
8. Test: `npx tsx sidecar/index.ts` must work identically to before

### Phase 2: Twilio audio adapter

1. Implement mulaw encode/decode in `sidecar/twilio-audio.ts`
2. Implement 8kHz <-> 16kHz and 24kHz <-> 8kHz resampling
3. Implement `twilioPayloadToFloat32` and `pcm24kToTwilioPayload`
4. Implement `createTwilioAudioAdapter` with WebSocket-based I/O
5. Implement chime caching (afconvert to temp file at init time)
6. Add WebSocket close tracking to silently handle writes to closed sockets

### Phase 3: Twilio server

1. Add `ws`, `twilio`, `dotenv`, `@types/ws` to package.json
2. Create `sidecar/twilio-server.ts` with HTTP server + TwiML endpoint
3. Load config from `.env` via dotenv. Fail fast if `TWILIO_AUTH_TOKEN` or `TWILIO_WEBHOOK_URL` are missing.
4. Add Twilio signature validation using `TWILIO_WEBHOOK_URL` for URL reconstruction
5. Add WebSocket server with per-call token validation via `activeCalls` map
6. Wire up: on valid WebSocket -> create TwilioAudioAdapter -> create voice session (session lock enforces the global limit)
7. If `createVoiceSession` throws (limit reached), respond with TwiML `<Say>` rejection
8. Register `ws.on('close')` for all cleanup (session stop + lock release + active call removal)
9. Wire `onSessionEnd` callback to call `ws.close()` (triggers `ws.on('close')` for cleanup)
10. Add `cleaned` flag to prevent double-cleanup re-entrancy

### Phase 4: Dashboard settings

1. Add `GET /api/settings` and `POST /api/settings` endpoints to `dashboard/server.ts`
2. Add settings panel to `dashboard/public/index.html` for editing `.env` values
3. Mask `TWILIO_AUTH_TOKEN` display (show last 4 chars only, reveal toggle)

### Phase 5: Integration test + tuning

1. Start Twilio server: `npx tsx sidecar/twilio-server.ts`
2. Start ngrok: `ngrok http 8080`
3. Configure Twilio phone number webhook to ngrok URL + `/twilio/incoming-call`
4. Call the phone number, verify end-to-end audio flow
5. Verify local mic path still works independently
6. Verify security: unauthenticated requests rejected
7. Verify: session limit works across processes (start local mic + phone call, both work; start a third session, gets rejected)
8. Verify: caller hangup mid-response cleans up session and releases lock
9. Verify: stale lock files from killed processes are cleaned up on next session start
10. Tune `interruptionThresholdMs` for phone calls (start at 2000ms, adjust based on false interruption rate)
11. Verify: dashboard settings panel reads/writes .env correctly

---

## Success Criteria

- Local mic path (`npx tsx sidecar/index.ts`) works identically to before the refactor
- Phone calls via Twilio flow through the full pipeline: caller speaks -> VAD -> STT -> Claude -> narrator -> TTS -> caller hears response
- Ready chime plays on phone calls after each Claude response
- User interruption works on phone calls (speak over Claude -> TTS stops, new utterance processed)
- Unauthenticated HTTP requests to the webhook return 403
- WebSocket connections with invalid tokens are rejected
- Each phone call gets its own independent Claude session
- Stop phrase ("stop listening") ends the session and hangs up
- Session limit enforced across processes (configurable via `.env` / dashboard)
- Stale lock files from crashed processes are automatically cleaned up
- Caller hangup mid-response tears down the session and releases the lock
- Twilio server fails fast on startup if required env vars are missing
- Dashboard settings panel allows editing all `.env` configuration
